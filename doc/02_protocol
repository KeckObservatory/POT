POT clients and servers communicate using ZeroMQ sockets. This document
describes the socket types and the formatting of the messages for the
various requests.

	- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

The first socket type implements a request/response socket pattern. This
represents the bulk of the interactive traffic between a POT client and
server. Because requests can be asynchronous, this does not use the
REQ/REP implementation in ZeroMQ, which enforces a strict one request,
one response pattern; instead, we use DEALER/ROUTER, which allows any
amount of messages at any time.

The handshaking between the client and server is of this form:

	Client says:	b'ACTION argument1 argument2 argument3'

	Server says:	bJSON: {'message': 'ACK',
				'id': eight hexadecimal digits,
				'time', timestamp for this acknowledgement,
				'data': first 32 characters of request}

All messages on the ZeroMQ sockets are formatted as raw bytes. The initial
Client request is simple enough that no formatting is necessary; the server
response is somewhat more involved, and JSON is used as a convenient and
portable way to encapsulate the response. The 'request' field is a truncated
readback of the request from the client; this allows the client to confirm
the server is responding to the correct request.

The ACK response comes back quickly. The absence of a quick response is an
indication to the client that the server is not available, and it should
immediately raise an error. After the client has received the initial ACK
it should then wait for the full response for its request:

	Server says:	bJSON: {'message': 'REP',
				'id': eight hexadecimal digits,
				'time', timestamp for this response,
				'name': unique name for this telemetry or data,
				'data': data according to request}


At this point the request is complete and no further messages will be issued,
unless and until the next request arrives.

The full exchange on the client side is represented by this sequence of
operations:

	zmq_context = zmq.Context()
        self.socket = zmq_context.socket(zmq.DEALER)
        self.socket.setsockopt(zmq.LINGER, 0)
        self.socket.identity = identity.encode()
        self.socket.connect(server)

	self.socket.send(request)
	result = self.socket.poll(100) # milliseconds
	if result == 0:
	    raise zmq.ZMQError('no response received in 100 ms')

	ack = self.socket.recv()
	response = self.socket.recv()

	- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

The second socket type implements a publish/subscribe socket pattern. The
desired functionality is a neat match for the PUB/SUB socket pattern offered
by ZeroMQ:

	* SUB clients subscribe to one or more "topics" from
	  a given PUB socket, or can subscribe to all topics
	  by subscribing to the empty string. This aligns well
	  with existing usage patterns, where KTL keyword
	  names and EPICS channel names are treated as unique
	  identifiers.

	* The filtering of "topics" occurs on the server side,
	  so if a PUB is publishing a mixture of high-frequency
	  or large broadcasts, and a client is not subscribed
	  to those "topics", the broadcasts are never sent to
	  the client.

The messages received by the client include the full topic as the leading
element in the message-as-bytes, followed by a space, followed by the remainder
of the message contents. The structure of a simple broadcast mimics the form
of the response described above:

	Server says:	b'unique_topic_string JSON...'

	JSON expanded:	{'message': 'PUB',
			 'id': eight hexadecimal digits,
			 'time', timestamp for this broadcast,
			 'name': unique name for this telemetry or data,
			 'data': data according to request}

There are two special cases of broadcast messages. These are identified by
a modifier on the "topic" string. If the identifier was, for example:

	kpfguide.LASTIMAGE

The contents of the JSON broadcast would be as described above:

			{'MESSAGE': 'PUB',
			 'id': deadbeef,
			 'time': 1715738507.234
			 'name': 'kpfguide.LASTIMAGE',
			 'data': JSON description of data,
			 'bulk': True}

The 'bulk' field is an indicator that there is a binary data blob that will
be broadcast in a separate message. The separate message would have a "topic"
identifier of:

	kpfguide.LASTIMAGE;bulk

The formatting of the on-the-wire message would be:

	b'kpfguide.LASTIMAGE;bulk deadbeef 6712437631249763124962431...'

...where the first whitespace-separated field after the "topic" is the same
unique identifier used in the initial broadcast, and all remaining data after
the space is a pure byte sequence. Both broadcasts must arrive in order for
either component to have any meaning; the 'data' from the first broadcast
will include enough information to reconstruct the binary blob, which at the
present time is only envisioned as image data, or more generally, something
that can be appropriately represented as a NumPy array.

The second type of special broadcast message is a bundle of related broadcasts.
If a server so chooses, it can collect related telemetry in a single broadcast;
this offers clients the option of treating the entire bundle as an atomic
entity. Each bundle is a sequence of simple JSON messages as described above.

If, for example, there was a bundle of telemetry messages relating to a filter
wheel, the individual items might have names like:

	deimot.FILTERNAM
	deimot.FILTERORD
	deimot.FILTERRAW

The POT server could elect to broadcast a single bundle containing all of those
values. The bundle message would have a "topic" identifier of:

	deimot.FILTER;bundle

The formatting of the on-the-wire message would be:

	b'deimot.FILTER;bundle JSON...'

...where the JSON would be a sequence of simple telemetry units as described
above:

	[{'message': 'PUB', 'id': eight hexadecimal digits, ...},
	 {'message': 'PUB', 'id': eight hexadecimal digits, ...},
	 {'message': 'PUB', 'id': eight hexadecimal digits, ...}]

The 'id' field would be identical for all messages in the bundle, and the
message type would be consistent, but all other fields would vary.
