POT clients and daemons communicate using ZeroMQ sockets. This document
describes the socket types and the formatting of the messages for the
various requests.

	- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

The first socket type implements a request/response pattern. This represents
the bulk of the interactive traffic between a POT client and deamon. Because
requests can be asynchronous, POT does not use the REQ/REP implementation in
ZeroMQ, which enforces a strict one request, one response pattern; instead,
we use DEALER/ROUTER, which allows any amount of messages at any time.

The handshaking between the client and daemon is of this form:

	Client says:	b'{'request': REQ, 'handshake': some integer, ...}

	Daemon says:	bJSON: {'message': 'ACK',
				'id': eight hexadecimal digits,
				'time', timestamp for this acknowledgement,
				'data': handshake integer}

All messages on the ZeroMQ sockets are formatted as raw bytes. JSON is used
as a convenient and portable way to encapsulate both the request and the
response. The 'data' identifier is somewhat generic, but the same field is
used for every response type, regardless of the request. In the case of the
ACK message, the 'data' is a recital of the initial handshake integer, so
enabling the client to tie the message back to the new unique identifier
provided by the daemon.

The ACK message comes back immediately upon receipt of the request. The
absence of a quick response is an indication to the client that the daemon
is not available, and it should immediately raise an error. After the client
has received the initial ACK it should then look for the full response:

	Daemon says:	bJSON: {'message': 'RESPONSE',
				'id': eight hexadecimal digits,
				'time', timestamp for this response,
				'name': unique POT key name,
				'data': response payload}

After receiving the RESPONSE message the request is complete and the daemon
will issue no further messages with this request ID. All requests are handled
fully asynchronously; a client could send a thousand requests in quick
succession, but the responses will not be serialized, and the response order
is not guaranteed. Synchronous behavior is implemented on the client side,
not in the protocol itself.

The full exchange on the client side is represented by this sequence of
operations, in this case treating it as a synchronous request:

        self.socket = zmq_context.socket(zmq.DEALER)
        self.socket.setsockopt(zmq.LINGER, 0)
        self.socket.identity = identity.encode()
        self.socket.connect(daemon)

	self.socket.send(request)
	result = self.socket.poll(100) # milliseconds
	if result == 0:
	    raise zmq.ZMQError('no response received in 100 ms')

	ack = self.socket.recv()
	response = self.socket.recv()

Some responses may include a bulk data component. These will be distinguished
by having a 'REP+B' message type. If the 'name' was, for example:

	kpfguide.LASTIMAGE

The contents of the REP+B response may look like:

			{'message': 'REP+B',
			 'id': 0xdeadbeef,
			 'time': 1715738507.234
			 'name': 'kpfguide.LASTIMAGE',
			 'data': JSON description of bulk data}

The '+B' on the message field indicates that a binary data blob will be sent
in a separate message. The separate message would have a topic identifier of:

	kpfguide.LASTIMAGE;bulk

The formatting of the on-the-wire message would be:

	b'kpfguide.LASTIMAGE;bulk deadbeef 6712437631249763124962431...'

...where the first whitespace separated field is largely noise for the REP+B
case, the important metadata is the message id linking it to the other half
of the response, but the message structure is identical to the PUB+B version
(which does need the "topic") so that any bulk data handling code can be
shared. The second whitespace separated field is the same unique identifier
found in the JSON from the other half of the response. All remaining data after
the subsequent whitespace is a pure byte sequence. Both messages must arrive
in order for either component to have any meaning; the 'data' from the JSON
response will include enough information to reconstruct the binary blob, which
at the present time is only envisioned as image data, or more generally,
something that can be represented as a NumPy array. Thus, the 'data' would
include information like the dimensions of the array and its datatype (int16,
uint32, float64, etc.).

	- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

This section is a description of the various requests a client can make of
the POT daemon via the request/response socket.

	'GET': request the current value for a single key. The key is always
		requested by its full unique name: the name of the store, and
		the name of the key, concatenated with a period. The data field
		will be as above in the description of the REQ/REP behavior;
		the data field will be the telemetry value, whether it is an
		integer, floating point number, string, boolean value, etc.
		Bulk data, as described above, is sent as raw bytes in a
		second message.

		Example request: b'GET kpfguide.DISP2MSG'

		Example request: b'GET kpfguide.DISP3STA'

	'SET': request a change to the value of a single key. Depending on
		the daemon, this could result in a variety of behavior, from
		simply caching the value to slewing a telescope, and anything
		in-between. The request data is formatted in JSON in order
		to mitigate formatting issues for transporting the new value
		over the wire (embedded whitespace, etc.).

		Example request: b'SET {'name': kpfguide.EXPTIME, 'data': 4}

	'ID': request the current cache identifier for the configuration
		of a single POT store. If no store name is specified, all
		available cache identifiers will be returned, for all known
		stores. An error will be returned if a store is requested
		and the contacted daemon does not have a cached configuration
		describing it.

		Each identifier is up to eight hexadecimal digits. It is
		expected that the identifiers for a given store will be
		sequential, but is not strictly required.

		To unify processing the response is always a sequence of
		individual identifiers, even if the sequence is only one
		element long.

		Example request: b'ID'

		Response data: [{'name': kpfguide, 'id': 84a30b35},
				{'name': kpfmet, 'id': 983ae10f}]

		Example request: b'ID kpfguide'

		Response data: [{'name': kpfguide, 'id': 84a30b35},]

	'CONFIG': request the full configuration contents for a single POT
		store. There is no option to dump the configuration data for
		all known stores. A typical client interaction will request
		the configuration ID first, and if the local copy is not a
		match, request the full contents from the daemon to update
		the local cache.

		The configuration contents are not fully described here,
		this is just a representation of the format.

		Example request: b'CONFIG kpfguide'

		Response data: {'name': kpfguide', 'id': 84a30b35,
				'keys': [{'name': 'DISP1CLK', ...},
					 {'name': 'DISP1STA', ...}
					 ...,
					 {'name': 'ZEDZEDTOP', ...}]}

	- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

The second socket type implements a publish/subscribe socket pattern. The
desired functionality is a neat match for the PUB/SUB socket pattern offered
by ZeroMQ:

	* SUB clients subscribe to one or more topics from
	  a given PUB socket, or can subscribe to all topics
	  by subscribing to the empty string. This aligns well
	  with existing usage patterns, where KTL keyword
	  names and EPICS channel names are treated as unique
	  identifiers, and map easily to the notion of a topic.

	* The filtering of topics occurs on the daemon side,
	  so if a PUB is publishing a mixture of high-frequency
	  values or large broadcasts, and a client is not
	  subscribed to those topics, the broadcasts are never
	  sent to the client.

The ZeroMQ messages received by the client include the full topic as the
leading element in the message-as-bytes, followed by a space, followed by
the remainder of the message contents. The structure of a simple broadcast
mimics the form of the request/response exchange described above:

	Daemon says:	b'unique_topic_string JSON...'

	JSON expanded:	{'message': 'PUB',
			 'id': eight hexadecimal digits,
			 'time', timestamp for this broadcast,
			 'name': unique POT key name,
			 'data': data according to request}

There are two special types of broadcast messages. These are distinguished
by a modifier on the topic string. The first type is the bulk/binary data
broadcast type, as described above for a REP+B response; there is a similar
PUB+B broadcast with otherwise exactly the same structure.

The second type of special broadcast message is a bundle of related broadcasts.
If a daemon so chooses, it can collect related telemetry in a single broadcast;
this offers clients the option of treating the entire bundle as an atomic
entity. Each bundle is a sequence of simple JSON messages as described above.

If, for example, there was a bundle of telemetry messages relating to a filter
wheel, the individual items might have names like:

	deimot.FILTERNAM
	deimot.FILTERORD
	deimot.FILTERRAW

The POT daemon could elect to broadcast a single bundle containing all of those
values. The bundle message would have a topic identifier of:

	deimot.FILTER;bundle

The formatting of the on-the-wire message would be:

	b'deimot.FILTER;bundle JSON...'

...where the JSON would be a sequence of individual PUB elements as described
above:

	[{'message': 'PUB', 'id': 0x0123abcd, 'name': deimot.FILTERNAM, ...},
	 {'message': 'PUB', 'id': 0x0123abcd, 'name': deimot.FILTERORD, ...},
	 {'message': 'PUB', 'id': 0x0123abcd, 'name': deimot.FILTERRAW, ...}]

The 'id' field would be identical for all messages in the bundle, but all
remaining fields would vary according to the message contents.

	- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

This section is a description of the various fields used in the JSON messaging
described above.

	'message': a one-word assertion of the type of content represented
		by this JSON. It is one of a few values:

		'ACK': immediate acknowledgement of a request. If this
			response is not received with a very small time
			window after the initial request, the client can
			and should assume the daemon handling that request
			is offline.

		'REP': a response to a direct request. This will contain
			the full data responding to a request to get a
			value, or the completion status of setting a value.

		'REP+B': same as 'REP' except that a second message will
			arrive with the contents of the bulk data.

		'PUB': an asynchronous broadcast of an event. There aren't
			any other types of message that will arrive on a
			SUB socket, the inclusion of this field is strictly
			for symmetry's sake.

		'PUB+B': same as 'PUB' except that a second message will
			arrive with the contents of the bulk data.

	'id': an eight character hexadecimal value reasonably unique to
		this specific transaction. The 'unique' constraint doesn't
		need to extend beyond a few minutes, at most, for any
		transaction; the id allows the client to tie together
		ACK and REP messages, to combine the JSON with the data
		buffer for a 'bulk' broadcast, and to further associate
		individual PUB messages contained in a 'bundle' broadcast.

	'time': a UNIX epoch timestamp associated with the generation of
		the event. This is not intended to represent any time
		prior to the actual broadcast or response, it is intended
		to represent the time at which that message was created,
		such that 'now' - 'time' should represent the transmission
		and POT handling delay between the daemon and the client.
		This timestamp should not be expected to represent the
		last known change of the value in question, though in some
		(if not most) cases it will be a reasonable approximation.

	'name': the unique POT key name, or the unique POT store name for
		some of the metadata queries. The POT key name, at the
		protocol level, is a concatenation of the POT store name
		and the key name within that store. In KTL parlance, this
		would be the service.KEYWORD name; in EPICS parlance, it
		would be the full IOC+channel name, as one might use with
		caput or caget on the command line.

	'data': the real payload of the message. For a read operation, this
		will be the telemetry requested, whether it be a string,
		integer, floating point number, or short sequence. For a
		response with no data this field will either not be present
		or it will be the JSON null value.

	'error': a JSON dictionary with information about any error that
		occurred while processing the request. If the value is
		not present or is the JSON null value, no error occurred.
		If it is present, it will have these values:

		'type': analagous to the Python exception type (ValueError,
			TypeError, etc.).

		'text': descriptive text of the error.

		The intent of this error field is not to provide enough
		information for debugging of code, it is intended to
		provide enough information to the client for it to perform
		meaningful error handling.
